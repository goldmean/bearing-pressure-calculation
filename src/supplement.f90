MODULE SUPPLEMENT

    USE APPROXIMATION

    IMPLICIT NONE

    INTEGER, PRIVATE, PARAMETER :: RESUNIT = 1, RIGUNIT = 2, PREUNIT = 3, SOLUNIT = 4

    PUBLIC :: CREATE_MESH, CALCULATE_PRESSURE, CALCULATE_RIGIDITY, CREATE_FILES, &
        CALCULATE_ANALYTICAL_SOLUTION

    PRIVATE :: INITIAL_CONDITIONS, CALCULATE_LIFT, ANALYTICAL_SOLUTION, &
        BOUNDARY_CONDITION, BISECTION

CONTAINS

    SUBROUTINE CREATE_MESH(NI, NJ, EXTERNAL_RADIUS, EXTERNAL_ANGLE, RADIUS_STEP, &
            ANGLE_STEP, RADIUS, ANGLE)
        IMPLICIT NONE

        INTEGER :: I, J
        INTEGER, INTENT(IN) :: NI, NJ
        DOUBLE PRECISION, INTENT(IN) :: EXTERNAL_RADIUS, EXTERNAL_ANGLE
        DOUBLE PRECISION, INTENT(OUT) :: RADIUS_STEP, ANGLE_STEP
        DOUBLE PRECISION, INTENT(OUT), DIMENSION(:, :) :: RADIUS, ANGLE

        RADIUS_STEP = EXTERNAL_RADIUS / (NI - 1)
        ANGLE_STEP = EXTERNAL_ANGLE / (NJ - 1)

        DO I = 1, NI
            DO J = 1, NJ
                RADIUS(I, J) = (I - 1) * RADIUS_STEP
                ANGLE(I, J) = (J - 1) * ANGLE_STEP
            END DO
        END DO

    END SUBROUTINE CREATE_MESH

    SUBROUTINE INITIAL_CONDITIONS(ATMOSPHERIC_PRESSURE, PRESSURE, PREVIOUS)
        IMPLICIT NONE

        DOUBLE PRECISION, INTENT(IN) :: ATMOSPHERIC_PRESSURE
        DOUBLE PRECISION, INTENT(OUT), DIMENSION(:, :) :: PRESSURE, PREVIOUS

        PRESSURE = ATMOSPHERIC_PRESSURE
        PREVIOUS = ATMOSPHERIC_PRESSURE

    END SUBROUTINE INITIAL_CONDITIONS

    SUBROUTINE CALCULATE_PRESSURE(NI, NJ, REGIME, GROOVE_DEPTH, GROOVE_RADIUS, &
            EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, RADIUS, &
            PRESSURE, PREVIOUS, PRESSURE_LOGGING, ANALYTIC_LOGGING, ACCURACY, &
            RESIDUAL_, LIMIT, EPS)
        IMPLICIT NONE

        INTEGER :: STEP
        INTEGER, INTENT(IN) :: NI, NJ, LIMIT

        LOGICAL, INTENT(IN) :: PRESSURE_LOGGING, ANALYTIC_LOGGING
        CHARACTER(*), INTENT(IN) :: ACCURACY, RESIDUAL_

        DOUBLE PRECISION :: RESP0, RESP, LIFT
        DOUBLE PRECISION, INTENT(IN) :: REGIME, GROOVE_DEPTH, GROOVE_RADIUS, &
            EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, EPS
        DOUBLE PRECISION, INTENT(OUT), DIMENSION(:, :) :: RADIUS, PRESSURE, PREVIOUS

        CALL INITIAL_CONDITIONS(ATMOSPHERIC_PRESSURE, PRESSURE, PREVIOUS)

        IF (PRESSURE_LOGGING) THEN
            OPEN(UNIT=RESUNIT, FILE=RESIDUAL_, ACTION="WRITE")
            WRITE(RESUNIT, "(A)") 'VARIABLES = "STEP", "RESP", "LIFT"'
        END IF

        STEP = 0

        DO WHILE (STEP < LIMIT)
            STEP = STEP + 1

            IF (TRIM(ACCURACY) == "SINGLE") CALL SINGLE_ACCURACY(NI, NJ, REGIME, &
                GROOVE_DEPTH, GROOVE_RADIUS, EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, &
                RADIUS_STEP, ANGLE_STEP, RADIUS, PRESSURE, PREVIOUS)

            IF (TRIM(ACCURACY) == "DOUBLE") CALL DOUBLE_ACCURACY(NI, NJ, REGIME, &
                GROOVE_DEPTH, GROOVE_RADIUS, EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, &
                RADIUS_STEP, ANGLE_STEP, RADIUS, PRESSURE, PREVIOUS)

            CALL CALCULATE_LIFT(NI, NJ, RADIUS_STEP, ANGLE_STEP, ATMOSPHERIC_PRESSURE, &
                RADIUS, PRESSURE, LIFT)

            IF (STEP == 1) RESP0 = MAXVAL(ABS(PRESSURE - PREVIOUS))

            RESP = MAXVAL(ABS(PRESSURE - PREVIOUS)) / RESP0

            IF (PRESSURE_LOGGING .OR. ANALYTIC_LOGGING) THEN
                IF (ANALYTIC_LOGGING .AND. MOD(STEP, INT(5E4)) == 0 .OR. &
                    PRESSURE_LOGGING .AND. MOD(STEP, INT(1E3)) == 0) &
                    PRINT "(A, /, A, I6, 3X, 2(A, E12.6, 3X))", REPEAT("-", 57), &
                        "STEP = ", STEP, "RESP = ", RESP, "LIFT = ", LIFT
            END IF

            IF (PRESSURE_LOGGING) THEN
                WRITE(RESUNIT, "(I6, 3X, 2(E12.6, 3X))") STEP, RESP, LIFT
            END IF

            IF (RESP < EPS) EXIT

            PREVIOUS = PRESSURE
        END DO

    END SUBROUTINE CALCULATE_PRESSURE

    SUBROUTINE CALCULATE_LIFT(NI, NJ, RADIUS_STEP, ANGLE_STEP, ATMOSPHERIC_PRESSURE, &
        RADIUS, PRESSURE, LIFT)
        IMPLICIT NONE

        INTEGER :: I, J
        INTEGER, INTENT(IN) :: NI, NJ
        DOUBLE PRECISION, INTENT(IN) :: RADIUS_STEP, ANGLE_STEP, ATMOSPHERIC_PRESSURE
        DOUBLE PRECISION, INTENT(IN), DIMENSION(:, :) :: RADIUS, PRESSURE
        DOUBLE PRECISION, INTENT(OUT) :: LIFT

        LIFT = 0.

        DO I = 1, NI - 1
            DO J = 1, NJ - 1
                LIFT = LIFT + ((PRESSURE(I, J) - ATMOSPHERIC_PRESSURE) * &
                    RADIUS(I, J) + (PRESSURE(I, J + 1) - ATMOSPHERIC_PRESSURE) * &
                    RADIUS(I, J + 1) + (PRESSURE(I + 1, J) - ATMOSPHERIC_PRESSURE) * &
                    RADIUS(I + 1, J) + (PRESSURE(I + 1, J + 1) - ATMOSPHERIC_PRESSURE) * &
                    RADIUS(I + 1, J + 1)) / 4.0
            END DO
        END DO

        LIFT = LIFT * RADIUS_STEP * ANGLE_STEP

    END SUBROUTINE CALCULATE_LIFT

    SUBROUTINE CALCULATE_RIGIDITY(NI, NJ, REGIME, GROOVE_DEPTH, GROOVE_RADIUS, &
        EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, RADIUS, &
        PRESSURE, PREVIOUS, ACCURACY, RESIDUAL_, RIGIDITY_, LIMIT, EPS, &
        REGIME_MIN, REGIME_MAX, REGIME_STEP, CLEARANCE, CLEARANCE_STEP)
        IMPLICIT NONE

        INTEGER :: I, MAX
        INTEGER, INTENT(IN) :: NI, NJ, LIMIT

        CHARACTER(*), INTENT(IN) :: ACCURACY, RIGIDITY_, RESIDUAL_

        DOUBLE PRECISION :: TEMP, COEFF, LIFT, DIFF, REGIME, GROOVE_DEPTH, RIGIDITY
        DOUBLE PRECISION, INTENT(IN) :: GROOVE_RADIUS, EXTERNAL_RADIUS, &
            ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, REGIME_MIN, REGIME_MAX, &
            REGIME_STEP, CLEARANCE, CLEARANCE_STEP, EPS
        DOUBLE PRECISION, INTENT(OUT), DIMENSION(:, :) :: RADIUS, PRESSURE, PREVIOUS

        OPEN(UNIT=RIGUNIT, FILE=RIGIDITY_, ACTION="WRITE")

        WRITE(RIGUNIT, "(A)") 'VARIABLES = "REGIME", "LIFT", "RIGIDITY"'

        COEFF = GROOVE_DEPTH

        MAX = INT((REGIME_MAX - REGIME_MIN + REGIME_STEP) / REGIME_STEP)

        DO I = 1, MAX
            REGIME = REGIME_MIN + (I - 1) * REGIME_STEP
            TEMP = REGIME
            GROOVE_DEPTH = COEFF

            CALL CALCULATE_PRESSURE(NI, NJ, REGIME, GROOVE_DEPTH, GROOVE_RADIUS, &
                EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, &
                RADIUS, PRESSURE, PREVIOUS, .FALSE., .FALSE., ACCURACY, &
                RESIDUAL_, LIMIT, EPS)

            CALL CALCULATE_LIFT(NI, NJ, RADIUS_STEP, ANGLE_STEP, ATMOSPHERIC_PRESSURE, &
                RADIUS, PRESSURE, LIFT)

            REGIME = REGIME * (CLEARANCE / (CLEARANCE + CLEARANCE_STEP)) ** 3
            GROOVE_DEPTH = GROOVE_DEPTH * (CLEARANCE / (CLEARANCE + CLEARANCE_STEP)) ** 3

            CALL CALCULATE_PRESSURE(NI, NJ, REGIME, GROOVE_DEPTH, GROOVE_RADIUS, &
                EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, &
                RADIUS, PRESSURE, PREVIOUS, .FALSE., .FALSE., ACCURACY, &
                RESIDUAL_, LIMIT, EPS)

            CALL CALCULATE_LIFT(NI, NJ, RADIUS_STEP, ANGLE_STEP, ATMOSPHERIC_PRESSURE, &
                RADIUS, PRESSURE, DIFF)

            RIGIDITY = - (DIFF - LIFT) / CLEARANCE_STEP

            PRINT "(A, /, 3(A, E12.6, 3X))", REPEAT("-", 69), "REGIME = ", TEMP, &
                "LIFT = ", LIFT, "RIGIDITY = ", RIGIDITY

            WRITE(RIGUNIT, "(3(E12.6, 3X))") TEMP, LIFT, RIGIDITY
        END DO

        PRINT "(A)", REPEAT("-", 69)

    END SUBROUTINE CALCULATE_RIGIDITY

    FUNCTION ANALYTICAL_SOLUTION(COEFF, RADIUS, ATMOSPHERIC_PRESSURE) &
            RESULT(PRESSURE)
        IMPLICIT NONE

        DOUBLE PRECISION :: PRESSURE
        DOUBLE PRECISION, INTENT(IN) :: COEFF, RADIUS, ATMOSPHERIC_PRESSURE

        PRESSURE = SQRT(COEFF * LOG(RADIUS) + ATMOSPHERIC_PRESSURE ** 2)

    END FUNCTION ANALYTICAL_SOLUTION

    FUNCTION BOUNDARY_CONDITION(REGIME, COEFF, RADIUS, ATMOSPHERIC_PRESSURE) &
            RESULT(RETVAL)
        IMPLICIT NONE

        DOUBLE PRECISION :: RETVAL
        DOUBLE PRECISION, INTENT(IN) :: REGIME, COEFF, RADIUS, ATMOSPHERIC_PRESSURE

        RETVAL = 2.0 * REGIME * SQRT(ANALYTICAL_SOLUTION(COEFF, RADIUS, &
            ATMOSPHERIC_PRESSURE) * (1.0 - ANALYTICAL_SOLUTION(COEFF, RADIUS, &
            ATMOSPHERIC_PRESSURE))) + 4.0 * ATAN(1.0) * RADIUS * (COEFF / RADIUS)

    END FUNCTION BOUNDARY_CONDITION

    SUBROUTINE BISECTION(REGIME, COEFF, RADIUS, ATMOSPHERIC_PRESSURE)
        IMPLICIT NONE

        DOUBLE PRECISION, PARAMETER :: EPS = 1E-6
        DOUBLE PRECISION :: UPPER_COEFF, BOUND_COEFF
        DOUBLE PRECISION, INTENT(IN) :: REGIME, RADIUS, ATMOSPHERIC_PRESSURE
        DOUBLE PRECISION, INTENT(OUT) :: COEFF

        UPPER_COEFF = (1.0 - ATMOSPHERIC_PRESSURE ** 2) / LOG(RADIUS)
        BOUND_COEFF = - ATMOSPHERIC_PRESSURE ** 2 / LOG(RADIUS)

        DO WHILE(ABS(UPPER_COEFF - BOUND_COEFF) > EPS)
            COEFF = (UPPER_COEFF + BOUND_COEFF) / 2.0
            IF (BOUNDARY_CONDITION(REGIME, UPPER_COEFF, RADIUS, &
                ATMOSPHERIC_PRESSURE) * BOUNDARY_CONDITION(REGIME, COEFF, RADIUS, &
                ATMOSPHERIC_PRESSURE) < 0.) THEN
                BOUND_COEFF = COEFF
            ELSE
                UPPER_COEFF = COEFF
            END IF
        END DO

    END SUBROUTINE BISECTION

    SUBROUTINE CALCULATE_ANALYTICAL_SOLUTION(NI, NJ, REGIME, GROOVE_RADIUS, &
        EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, LIMIT, EPS, &
        RADIUS, PRESSURE, PREVIOUS, ACCURACY, RESIDUAL_, ANALYTIC_)
        IMPLICIT NONE

        INTEGER :: I, S
        INTEGER, INTENT(IN) :: NI, NJ, LIMIT

        CHARACTER(*), INTENT(IN) :: ACCURACY, RESIDUAL_, ANALYTIC_

        DOUBLE PRECISION :: GROOVE_DEPTH, COEFF, PRESSURE_
        DOUBLE PRECISION, INTENT(IN) :: REGIME, GROOVE_RADIUS, EXTERNAL_RADIUS, &
            ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, EPS
        DOUBLE PRECISION, INTENT(OUT), DIMENSION(:, :) :: RADIUS, PRESSURE, PREVIOUS

        GROOVE_DEPTH = 200.

        CALL CALCULATE_PRESSURE(NI, NJ, REGIME, GROOVE_DEPTH, GROOVE_RADIUS, &
            EXTERNAL_RADIUS, ATMOSPHERIC_PRESSURE, RADIUS_STEP, ANGLE_STEP, RADIUS, &
            PRESSURE, PREVIOUS, .FALSE., .TRUE., ACCURACY, RESIDUAL_, LIMIT, EPS)

        S = NINT(GROOVE_RADIUS / EXTERNAL_RADIUS * NI)

        CALL BISECTION(REGIME, COEFF, RADIUS(S, NJ), ATMOSPHERIC_PRESSURE)

        OPEN(UNIT=SOLUNIT, FILE=ANALYTIC_, ACTION="WRITE")

        WRITE(SOLUNIT, "(A)") 'VARIABLES = "RADIUS", "PRESSURE", "ANALYTIC"'

        DO I = 1, S - 1
            PRESSURE_ = ANALYTICAL_SOLUTION(COEFF, RADIUS(S, NJ), ATMOSPHERIC_PRESSURE)
            WRITE(SOLUNIT, "(3(E12.6, 3X))") RADIUS(I, NJ), PRESSURE(I, NJ), PRESSURE_
        END DO

        DO I = S, NI
            PRESSURE_ = ANALYTICAL_SOLUTION(COEFF, RADIUS(I, NJ), ATMOSPHERIC_PRESSURE)
            WRITE(SOLUNIT, "(3(E12.6, 3X))") RADIUS(I, NJ), PRESSURE(I, NJ), PRESSURE_
        END DO

        PRINT "(A)", REPEAT("-", 57)

    END SUBROUTINE CALCULATE_ANALYTICAL_SOLUTION

    SUBROUTINE CREATE_FILES(NI, NJ, RADIUS, ANGLE, PRESSURE, PRESSURE_)
        IMPLICIT NONE

        INTEGER, INTENT(IN) :: NI, NJ
        CHARACTER(*), INTENT(IN) :: PRESSURE_
        DOUBLE PRECISION, INTENT(IN), DIMENSION(:, :) :: RADIUS, ANGLE, PRESSURE

        OPEN(UNIT=PREUNIT, FILE=PRESSURE_, ACTION="WRITE")

        WRITE(PREUNIT, *) 'VARIABLES = "X", "Y", "P"'
        WRITE(PREUNIT, *) "ZONE I = ", NI, "J = ", NJ, ", DATAPACKING = BLOCK"
        WRITE(PREUNIT, "(100E25.16)") RADIUS * COS(ANGLE)
        WRITE(PREUNIT, "(100E25.16)") RADIUS * SIN(ANGLE)
        WRITE(PREUNIT, "(100E25.16)") PRESSURE

        CLOSE(UNIT=PREUNIT)

    END SUBROUTINE CREATE_FILES

END MODULE SUPPLEMENT
